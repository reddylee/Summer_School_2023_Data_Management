<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Data</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Data_files/libs/clipboard/clipboard.min.js"></script>
<script src="Data_files/libs/quarto-html/quarto.js"></script>
<script src="Data_files/libs/quarto-html/popper.min.js"></script>
<script src="Data_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Data_files/libs/quarto-html/anchor.min.js"></script>
<link href="Data_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Data_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Data_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Data_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Data_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Data</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="project-title-determinants-of-incumbent-overstay-attempts-and-outcomes" class="level2">
<h2 class="anchored" data-anchor-id="project-title-determinants-of-incumbent-overstay-attempts-and-outcomes">Project title: Determinants of Incumbent Overstay Attempts and Outcomes</h2>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>This study aims to provide a comprehensive analysis of the factors influencing political leaders’ decisions to either voluntarily step down or attempt to overstay in power. By employing a sample selection model, the research explores the ef‐ fects of economic performance, the post‐Cold War era, regime types, and levels of democracy on overstay attempts. Furthermore, it examines the influence of incumbency advantages on the likelihood of successful overstay attempts. Through a quantitative analysis based on a new dataset of overstays, this study contributes to the existing literature by offering valuable insights into the deter‐ minants of overstay attempts and their outcomes.</p>
</section>
<section id="data" class="level2">
<h2 class="anchored" data-anchor-id="data">Data</h2>
<section id="dependent-variable" class="level3">
<h3 class="anchored" data-anchor-id="dependent-variable">Dependent variable</h3>
<ul>
<li><strong>Event of attempts of overstays (<em>Attempts</em>)</strong>: 1 if the leader attempts to overstay; 0 otherwise.</li>
<li><strong>Success of overstays (<em>Success</em>)</strong>: 1 if the attempt succeeds; 0 if failed.</li>
</ul>
<p>The data is coded by the author of this study based on the dataset of incumbent takeover <span class="citation" data-cites="baturo2022">[@baturo2022]</span>.</p>
</section>
<section id="independent-variables" class="level3">
<h3 class="anchored" data-anchor-id="independent-variables">Independent variables</h3>
<ul>
<li><p><strong>Economic index (<em>GDPpc</em> &amp; <em>Eco_growth</em>)</strong>: The study utilizes GDP per capita and economic performance as key indicators of economic influence. Economic performance is measured by calculating the 5-year moving average GDP per capita, comparing the value in the year of overstays with the value from three years earlier. In cases where leaders do not attempt to overstay, the value from the end year of their ruling is used instead. The dataset comes from V-Dem Data.</p></li>
<li><p><strong>Post-Cold War (<em>postColdWar</em>)</strong>: 1 if the event occurs after 1990, 0 otherwise.</p></li>
<li><p><strong>Regime types (<em>Regime_type</em>):</strong> The regime types, as discussed in Part III, are based on the dataset coded by Anckar <span class="citation" data-cites="anckar2018">[@anckar2018]</span>.</p></li>
<li><p><strong>Degree of democracy (<em>polity</em>)</strong>: This study employs the scores of Polity 5 as a measurement to determine the degree of democracy in each country. To account for potential variations in Polity 5 scores over time within the same leader’s rule, this study utilizes the score corresponding to the event year in question.</p></li>
</ul>
</section>
<section id="control-variables" class="level3">
<h3 class="anchored" data-anchor-id="control-variables">Control variables</h3>
<ul>
<li><p><strong>Population size (<em>logpop</em>)</strong>: The population size (logged) for each country in this study is obtained from the V-Dem Data. Previous literature, including studies by <span class="citation" data-cites="wells1974">[@wells1974]</span>,<span class="citation" data-cites="barro1999determinants">[@barro1999determinants]</span>, and <span class="citation" data-cites="gassebner2016">[@gassebner2016]</span>, has examined the influence of country size, either in terms or land area and population, on politics. Building upon this research, this study posits that attempts to overstay in office are more likely to occur in countries with smaller populations. The rationale behind this is that incumbent leaders find it comparatively easier to maintain control over smaller countries. In such cases, the population size is smaller, resulting in fewer diverse interest groups, ethnicities, and religions. On the other hand, in larger countries with a larger population, there are more diverse groups and forces that can potentially oppose attempts to overstay in power.</p></li>
<li><p><strong>Entry mode (<em>entry</em>)</strong>: In this study, the entry mode is categorized as regular if a leader comes to power through a constitutional process such as an election. Conversely, the entry mode is classified as irregular if a leader assumes power through an unconstitutional means, such as a coup. The inclusion of the entry mode variable as a control variable in this study is based on the assumption that leaders who come to power in a regular manner are more likely to adhere to the original norms and established governance practices. The data regarding the entry mode is obtained from the Archigos Dataset<span class="citation" data-cites="goemans2009">[@goemans2009]</span>.</p></li>
<li><p><strong>Years in power (<em>years_in_power</em>)</strong>: The variable “years in power” captures the duration that incumbents have served in office up to the year of the event. In cases where the leader does not attempt to overstay their tenure, the entire duration of their time in power is coded. The rationale behind including the years in power variable is rooted in the assumption that the longer incumbents stay in office, the more powerful they become. It is believed that powerful leaders are more likely to succeed in their attempts to overstay in office, as their influence and control over the political system grow over time, which in turn encourages them to make such attempts.</p></li>
</ul>
</section>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<p>This study utilizes the sample selection model based on <span class="citation" data-cites="heckman1979">@heckman1979</span> to conduct the regression analysis and assess the impact of different variables on the probabilities of overstays, including both the attempts and the likelihood of success. The utilization of the sample selection model aims to mitigate selection bias, as the decision of whether an incumbent chooses to attempt to overstay is heavily influenced by the prospects for success. Additionally, the <strong><em><code>probit</code></em></strong> model is utilized alongside the sample selection model to examine and compare the results.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>